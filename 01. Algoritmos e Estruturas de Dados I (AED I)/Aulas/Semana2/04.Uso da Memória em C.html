
<!-- saved from url=(0063)http://www.each.usp.br/digiampietri/ACH2023/usodememoriaemc.htm -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, ::-webkit-calendar-picker-indicator {
    filter: invert(100%) hue-rotate(180deg) contrast(70%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #292a2b;
   --darkreader-neutral-text: #c6c3bf;
   --darkreader-selection-background: #1957a2;
   --darkreader-selection-text: #d3d2cf;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><script class="darkreader darkreader--proxy">(function injectProxy() {
        document.dispatchEvent(
            new CustomEvent("__darkreader__inlineScriptsAllowed")
        );
        const addRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "addRule"
        );
        const insertRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "insertRule"
        );
        const deleteRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "deleteRule"
        );
        const removeRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "removeRule"
        );
        const shouldWrapDocStyleSheets =
            location.hostname.endsWith("pushbullet.com") ||
            location.hostname.endsWith("ilsole24ore.com") ||
            location.hostname.endsWith("allegro.pl");
        const documentStyleSheetsDescriptor = shouldWrapDocStyleSheets
            ? Object.getOwnPropertyDescriptor(Document.prototype, "styleSheets")
            : null;
        const cleanUp = () => {
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "addRule",
                addRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "insertRule",
                insertRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "deleteRule",
                deleteRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "removeRule",
                removeRuleDescriptor
            );
            document.removeEventListener("__darkreader__cleanUp", cleanUp);
            document.removeEventListener(
                "__darkreader__addUndefinedResolver",
                addUndefinedResolver
            );
            if (shouldWrapDocStyleSheets) {
                Object.defineProperty(
                    Document.prototype,
                    "styleSheets",
                    documentStyleSheetsDescriptor
                );
            }
        };
        const addUndefinedResolver = (e) => {
            customElements.whenDefined(e.detail.tag).then(() => {
                document.dispatchEvent(
                    new CustomEvent("__darkreader__isDefined", {
                        detail: {tag: e.detail.tag}
                    })
                );
            });
        };
        document.addEventListener("__darkreader__cleanUp", cleanUp);
        document.addEventListener(
            "__darkreader__addUndefinedResolver",
            addUndefinedResolver
        );
        const updateSheetEvent = new Event("__darkreader__updateSheet");
        function proxyAddRule(selector, style, index) {
            addRuleDescriptor.value.call(this, selector, style, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return -1;
        }
        function proxyInsertRule(rule, index) {
            const returnValue = insertRuleDescriptor.value.call(
                this,
                rule,
                index
            );
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return returnValue;
        }
        function proxyDeleteRule(index) {
            deleteRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyRemoveRule(index) {
            removeRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyDocumentStyleSheets() {
            const docSheets = documentStyleSheetsDescriptor.get.call(this);
            const filtered = [...docSheets].filter((styleSheet) => {
                return !styleSheet.ownerNode.classList.contains("darkreader");
            });
            return Object.setPrototypeOf(filtered, StyleSheetList.prototype);
        }
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "addRule",
            Object.assign({}, addRuleDescriptor, {value: proxyAddRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "insertRule",
            Object.assign({}, insertRuleDescriptor, {value: proxyInsertRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "deleteRule",
            Object.assign({}, deleteRuleDescriptor, {value: proxyDeleteRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "removeRule",
            Object.assign({}, removeRuleDescriptor, {value: proxyRemoveRule})
        );
        if (shouldWrapDocStyleSheets) {
            Object.defineProperty(
                Document.prototype,
                "styleSheets",
                Object.assign({}, documentStyleSheetsDescriptor, {
                    get: proxyDocumentStyleSheets
                })
            );
        }
    })()</script><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #2d2e2f !important;
}
html, body, input, textarea, select, button {
    background-color: #2d2e2f;
}
html, body, input, textarea, select, button {
    border-color: #766f65;
    color: #d3d2cf;
}
a {
    color: #428ee6;
}
table {
    border-color: #5d6265;
}
::placeholder {
    color: #a8a29a;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #5e6219 !important;
    color: #d3d2cf !important;
}
::-webkit-scrollbar {
    background-color: #333536;
    color: #a29d94;
}
::-webkit-scrollbar-thumb {
    background-color: #515557;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #5f6568;
}
::-webkit-scrollbar-thumb:active {
    background-color: #53585a;
}
::-webkit-scrollbar-corner {
    background-color: #2d2e2f;
}
::selection {
    background-color: #1957a2 !important;
    color: #d3d2cf !important;
}
::-moz-selection {
    background-color: #1957a2 !important;
    color: #d3d2cf !important;
}</style>
    <title>Uso da Memória em C</title>
  <meta name="darkreader" content="c64d019159a7c85b1aa2447a0211933b"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7c5c08 !important;
    border-color: #c6a629 !important;
    color: #dcd3b9 !important;
}
::placeholder {
    opacity: 0.5 !important;
}
a[href="https://coinmarketcap.com/"] > svg[width="94"][height="16"] > path {
    fill: var(--darkreader-neutral-text) !important;
}
#edge-translate-panel-body {
    color: var(--darkreader-neutral-text) !important;
}</style></head>
  <body>

<b>Uso da Memória em C <font size="1">(retirado do Capítulo 7 do livro "C 
programação: o guia prático para a programação eficiente" de Steven Holzner)</font></b><p>
É importante entender o que se passa na memória durante a execução de um 
programa C. Poucas linguagens de alto nível dão tanta atenção quanto C à 
manutenção e ao gerenciamento da memória; por essa razão, é crucial para nós 
como programadores C sabermos o que está acontecendo com as nossas variáveis, 
como elas são alocadas (porque, quando elas são realocadas por um programa C, os 
dados originais são perdidos), e como alocarmos nós mesmos grandes seções de 
memória para nosso uso.</p>
<p>Em C, a memória é dividida em várias seções diferentes. Existe a <b>área de 
código</b>, onde residem as instruções do programa; essa área não é modificada 
quando um programa é executado. A área seguinte é a <b>área de dados</b>, que é 
por sua vez dividida em duas seções, uma para dados inicializados e outra para 
dados não-inicializados.</p>
<p>Além disso, é definida uma área no topo da memória disponível, e essa região 
se expande em direção à parte baixa da memória, à proporção que é preenchida. 
Essa área é denominada <b>pilha</b>, e C aloca espaço para a maioria das 
variáveis nessa região. A última área de memória está localizada na <b>memória 
alocável</b>, e pode crescer em tamanho exatamente como a pilha, exceto pelo 
fato de se expandir em direção à memória mais alta, e não para baixo, em direção 
à memória mais baixa. Na verdade, a própria linguagem C usualmente mantém a 
pilha por nós, mas a alocação e o uso da memória na área da memória alocável são 
de nossa responsabilidade. Existe uma variedade de rotinas de biblioteca, 
projetadas para alocar espaço de memória para nós na área de memória alocável; 
na verdade, uma delas já foi vista, a função <b>malloc( )</b>, que faz 
exatamente isso.</p>
<p>&nbsp;</p>

<center>
<img src="./04.Uso da Memória em C_files/memoriac.png">
</center>

  
</body></html>